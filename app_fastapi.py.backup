"""
FastAPI application for Chitra Photo Management.
Migrated from Flask with full async support and MinIO storage.
"""
from __future__ import annotations

import os
from contextlib import asynccontextmanager
from typing import AsyncIterator

from fastapi import FastAPI, Depends, HTTPException, Query, UploadFile, File, Form
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, Response, StreamingResponse

import aiosqlite
import asyncio
from concurrent.futures import ThreadPoolExecutor
from typing import List

from core import db_async
from core.storage_client import MinIOStorageClient
from core.embedder import ClipEmbedder
from core.extractor import collect_metadata, load_image, iter_images, RAW_EXTS
from core.gallery import ensure_thumb
from core.cache import get_cached_thumbnail, cache_thumbnail
from core.worker import get_queue
from core.jobs import process_photo_embedding_job, process_photo_faces_job
from PIL import Image


# Global instances
_STORAGE_CLIENT: MinIOStorageClient | None = None
_EMBEDDER: ClipEmbedder | None = None

# Database path
DB_PATH = os.environ.get("CHITRA_DB_PATH", db_async.DB_DEFAULT_PATH)


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Lifespan context manager for startup/shutdown."""
    # Startup
    global _STORAGE_CLIENT, _EMBEDDER
    
    # Initialize storage client (lazy - will connect when needed)
    try:
        _STORAGE_CLIENT = MinIOStorageClient()
        print("✓ MinIO storage client initialized")
    except Exception as e:
        print(f"Warning: MinIO storage client initialization failed: {e}")
        print("  MinIO will be initialized on first use")
        _STORAGE_CLIENT = None
    
    # Initialize database if needed
    try:
        async with db_async.connect_async(DB_PATH) as conn:
            await db_async.init_db_async(DB_PATH)
        print("✓ Database initialized")
    except Exception as e:
        print(f"Warning: Database initialization failed: {e}")
    
    yield
    
    # Shutdown
    _STORAGE_CLIENT = None
    _EMBEDDER = None


# Create FastAPI app
app = FastAPI(
    title="Chitra Photo Management API",
    description="Photo management with embeddings and face detection",
    version="2.0.0",
    lifespan=lifespan
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Configure appropriately for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# -----------------------------------------------------------------------------
# DEPENDENCY INJECTION
# -----------------------------------------------------------------------------

async def get_db_async() -> AsyncIterator[aiosqlite.Connection]:
    """Dependency: Get async database connection."""
    async with db_async.connect_async(DB_PATH) as conn:
        yield conn


def get_storage_client() -> MinIOStorageClient:
    """Dependency: Get MinIO storage client."""
    global _STORAGE_CLIENT
    if _STORAGE_CLIENT is None:
        try:
            _STORAGE_CLIENT = MinIOStorageClient()
        except Exception as e:
            raise HTTPException(
                status_code=503,
                detail=f"Storage service unavailable: {str(e)}"
            )
    return _STORAGE_CLIENT


def get_embedder() -> ClipEmbedder:
    """Dependency: Get CLIP embedder (sync, use in thread pool)."""
    global _EMBEDDER
    if _EMBEDDER is None:
        _EMBEDDER = ClipEmbedder()
    return _EMBEDDER


# -----------------------------------------------------------------------------
# HEALTH CHECK
# -----------------------------------------------------------------------------

@app.get("/api/health")
async def health_check():
    """
    Health check endpoint.
    Tests database and MinIO connectivity.
    """
    health_info = {
        "status": "ok",
        "version": "2.0.0",
        "db_path": str(DB_PATH),
    }
    
    # Test database
    try:
        async with db_async.connect_async(DB_PATH) as conn:
            await conn.execute("SELECT 1")
        health_info["db_status"] = "ok"
    except Exception as e:
        health_info["db_status"] = f"error: {str(e)}"
        health_info["status"] = "degraded"
    
    # Test MinIO storage (optional - don't fail if unavailable)
    try:
        storage = get_storage_client()
        # Try to list buckets (lightweight operation)
        storage.client.list_buckets()
        health_info["storage_status"] = "ok"
        health_info["storage_endpoint"] = storage.endpoint
        health_info["storage_bucket"] = storage.bucket_name
    except Exception as e:
        health_info["storage_status"] = f"unavailable: {str(e)[:100]}"
        health_info["status"] = "degraded"
        health_info["storage_note"] = "MinIO server not running or unreachable"
    
    # Return 200 even if degraded (service is still functional)
    return JSONResponse(content=health_info, status_code=200)


# -----------------------------------------------------------------------------
# ROOT ENDPOINT
# -----------------------------------------------------------------------------

@app.get("/")
async def root():
    """Root endpoint."""
    return {
        "message": "Chitra Photo Management API",
        "version": "2.0.0",
        "docs": "/docs",
        "health": "/api/health"
    }


# -----------------------------------------------------------------------------
# HELPERS
# -----------------------------------------------------------------------------

def row_to_photo_dto(row) -> Dict[str, Any]:
    """Convert database row to photo DTO."""
    return {
        "id": row["id"],
        "file_path": row["file_path"],
        "size": row["size"],
        "created_at": row["created_at"],
        "checksum": row["checksum"],
        "phash": row["phash"],
        "exif_datetime": row["exif_datetime"],
        "latitude": row["latitude"],
        "longitude": row["longitude"],
        "thumb_path": row.get("thumb_path"),
    }


async def ensure_photo_thumb_async(
    file_path: str,
    photo_id: int,
    storage: MinIOStorageClient,
    conn: aiosqlite.Connection
) -> str:
    """
    Ensure thumbnail exists on MinIO. Returns MinIO object key.
    """
    thumb_path = storage.generate_thumbnail_path(photo_id, "photo")
    
    # Check if thumbnail exists on MinIO
    if not await storage.file_exists_async(thumb_path):
        # Download original, generate thumb, upload
        file_data = await storage.download_file_async(file_path)
        
        with tempfile.NamedTemporaryFile(delete=False, suffix=Path(file_path).suffix) as tmp:
            tmp.write(file_data)
            tmp_path = tmp.name
        
        try:
            # Generate thumbnail
            thumb_file_path = str(Path(tmp_path).with_suffix('.jpg'))
            ensure_thumb(tmp_path, thumb_file_path)
            
            # Check if thumbnail was actually created
            if not os.path.exists(thumb_file_path):
                raise Exception(f"Thumbnail generation failed: {thumb_file_path} was not created")
            
            # Read thumbnail and upload
            with open(thumb_file_path, 'rb') as f:
                thumb_data = f.read()
            await storage.upload_file_async(thumb_data, thumb_path)
        finally:
            if os.path.exists(tmp_path):
                os.unlink(tmp_path)
            if os.path.exists(thumb_file_path):
                os.unlink(thumb_file_path)
    
    return thumb_path


# -----------------------------------------------------------------------------
# PHOTO ENDPOINTS
# -----------------------------------------------------------------------------

@app.get("/api/photos")
async def list_photos(
    limit: int = Query(100, ge=1, le=1000),
    offset: int = Query(0, ge=0),
    conn: aiosqlite.Connection = Depends(get_db_async)
):
    """List photos with pagination."""
    cur = await conn.cursor()
    await cur.execute(
        """SELECT * FROM photos ORDER BY id DESC LIMIT ? OFFSET ?""",
        (limit, offset),
    )
    rows = await cur.fetchall()
    
    items = [row_to_photo_dto(dict(row)) for row in rows]
    return {"items": items, "limit": limit, "offset": offset}


@app.get("/api/photos/{photo_id}")
async def get_photo(
    photo_id: int,
    conn: aiosqlite.Connection = Depends(get_db_async)
):
    """Get photo details by ID."""
    cur = await conn.cursor()
    await cur.execute("SELECT * FROM photos WHERE id=?", (photo_id,))
    row = await cur.fetchone()
    
    if not row:
        raise HTTPException(status_code=404, detail="photo_not_found")
    
    return row_to_photo_dto(dict(row))


@app.get("/api/photos/{photo_id}/image")
async def get_photo_image(
    photo_id: int,
    conn: aiosqlite.Connection = Depends(get_db_async),
    storage: MinIOStorageClient = Depends(get_storage_client)
):
    """Download photo image."""
    cur = await conn.cursor()
    await cur.execute("SELECT file_path FROM photos WHERE id=?", (photo_id,))
    row = await cur.fetchone()
    
    if not row:
        raise HTTPException(status_code=404, detail="photo_not_found")
    
    file_path = row["file_path"]
    
    # Download from MinIO
    try:
        file_data = await storage.download_file_async(file_path)
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail="file_not_found_on_storage")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"storage_error: {str(e)}")
    
    # Check if file needs conversion (RAW or HEIC/HEIF)
    file_ext = Path(file_path).suffix.lower()
    heic_exts = {".heic", ".heif"}
    
    if file_ext in RAW_EXTS or file_ext in heic_exts:
        # Process in temporary file
        with tempfile.NamedTemporaryFile(delete=False, suffix=file_ext) as tmp:
            tmp.write(file_data)
            tmp_path = tmp.name
        
        try:
            img = load_image(Path(tmp_path))
            # Convert PIL Image to JPEG bytes
            img_io = io.BytesIO()
            img.save(img_io, format='JPEG', quality=95)
            img_io.seek(0)
            return Response(
                content=img_io.read(),
                media_type='image/jpeg',
                headers={"Cache-Control": "public, max-age=86400"}
            )
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"failed_to_convert: {str(e)}")
        finally:
            if os.path.exists(tmp_path):
                os.unlink(tmp_path)
    
    # Serve directly
    ext = Path(file_path).suffix.lower()
    mimetype = {
        '.jpg': 'image/jpeg', '.jpeg': 'image/jpeg',
        '.png': 'image/png', '.gif': 'image/gif',
        '.webp': 'image/webp',
    }.get(ext, 'application/octet-stream')
    
    return Response(
        content=file_data,
        media_type=mimetype,
        headers={"Cache-Control": "public, max-age=86400"}
    )


@app.get("/api/photos/{photo_id}/thumbnail")
async def get_photo_thumbnail(
    photo_id: int,
    conn: aiosqlite.Connection = Depends(get_db_async),
    storage: MinIOStorageClient = Depends(get_storage_client)
):
    """Get photo thumbnail."""
    cur = await conn.cursor()
    await cur.execute("SELECT file_path, thumb_path FROM photos WHERE id=?", (photo_id,))
    row = await cur.fetchone()
    
    if not row:
        raise HTTPException(status_code=404, detail="photo_not_found")
    
    file_path = row["file_path"]
    thumb_path = row["thumb_path"]
    
    # If thumb_path not in DB, generate it and store
    if not thumb_path:
        thumb_path = await ensure_photo_thumb_async(file_path, photo_id, storage, conn)
        await conn.execute("UPDATE photos SET thumb_path = ? WHERE id = ?", (thumb_path, photo_id))
        await conn.commit()
    else:
        # Check if thumbnail exists on MinIO (only if we have path in DB)
        if not await storage.file_exists_async(thumb_path):
            # Thumbnail was deleted or doesn't exist, regenerate
            thumb_path = await ensure_photo_thumb_async(file_path, photo_id, storage, conn)
            await conn.execute("UPDATE photos SET thumb_path = ? WHERE id = ?", (thumb_path, photo_id))
            await conn.commit()
    
    # Check cache first
    thumb_data = get_cached_thumbnail(thumb_path)
    
    if thumb_data is None:
        # Download from MinIO
        try:
            thumb_data = await storage.download_file_async(thumb_path)
            # Cache for future requests
            cache_thumbnail(thumb_path, thumb_data)
        except FileNotFoundError:
            raise HTTPException(status_code=404, detail="thumbnail_not_found_on_storage")
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"storage_error: {str(e)}")
    
    return Response(
        content=thumb_data,
        media_type='image/jpeg',
        headers={"Cache-Control": "public, max-age=86400"}
    )


@app.post("/api/photos/upload")
async def upload_photos(
    files: List[UploadFile] = File(...),
    auto_process: bool = Form(True),
    storage: MinIOStorageClient = Depends(get_storage_client)
):
    """Upload photos (supports multiple files)."""
    if not files:
        raise HTTPException(status_code=400, detail="no_files")
    
    # Read all file data upfront
    file_data_list = []
    for file in files:
        if not file.filename:
            continue
        file_data = await file.read()
        file_data_list.append((file.filename, file_data))
    
    if not file_data_list:
        raise HTTPException(status_code=400, detail="no_valid_files")
    
    async def upload_single_file_async(filename: str, file_data: bytes) -> Dict[str, Any]:
        """Upload a single file asynchronously."""
        tmp_path = None
        thumb_file_path = None
        try:
            async with db_async.connect_async(DB_PATH) as conn:
                # Upload to MinIO storage
                remote_path = storage.generate_photo_path(filename)
                
                # Ensure uniqueness - check database first
                counter = 1
                base_path = remote_path
                cur = await conn.cursor()
                while True:
                    await cur.execute("SELECT id FROM photos WHERE file_path=?", (remote_path,))
                    row = await cur.fetchone()
                    if row is None:
                        # Not in database, check MinIO only if needed (for safety)
                        if not await storage.file_exists_async(remote_path):
                            break
                    # Path exists, generate new one
                    path_obj = Path(base_path)
                    ext = path_obj.suffix
                    name = path_obj.stem
                    remote_path = f"{path_obj.parent}/{name}_{counter}{ext}"
                    counter += 1
                
                # Upload to MinIO
                stored_path = await storage.upload_file_async(file_data, remote_path)
                
                # Process metadata using temporary file
                with tempfile.NamedTemporaryFile(delete=False, suffix=Path(filename).suffix) as tmp:
                    tmp.write(file_data)
                    tmp_path = tmp.name
                
                # Collect metadata
                meta = collect_metadata(Path(tmp_path))
                # Store MinIO path
                meta['file_path'] = stored_path
                await db_async.upsert_photo_async(conn, **meta)
                
                # Get photo ID
                cur = await conn.cursor()
                await cur.execute("SELECT id FROM photos WHERE file_path=?", (stored_path,))
                row = await cur.fetchone()
                if not row:
                    return {"error": f"Failed to get photo ID for {filename}"}
                photo_id = row["id"]
                
                # Generate thumbnail
                thumb_path = await ensure_photo_thumb_async(stored_path, photo_id, storage, conn)
                
                # Store thumb_path in database
                await conn.execute("UPDATE photos SET thumb_path = ? WHERE id = ?", (thumb_path, photo_id))
                await conn.commit()
                
                # Auto-process: embeddings and faces (if enabled)
                if auto_process:
                    try:
                        queue = get_queue()
                        # Queue embedding processing job
                        queue.enqueue(
                            process_photo_embedding_job,
                            photo_id,
                            stored_path,
                            DB_PATH,
                            job_timeout='10m'
                        )
                        # Queue face processing job
                        queue.enqueue(
                            process_photo_faces_job,
                            photo_id,
                            stored_path,
                            DB_PATH,
                            job_timeout='10m'
                        )
                    except Exception as e:
                        # Don't fail upload if job queuing fails
                        print(f"Warning: Failed to queue processing jobs for {filename}: {e}")
                
                return {
                    "id": photo_id,
                    "file_path": stored_path,
                    "storage_url": f"/api/storage/{stored_path}",
                    "thumbnail": thumb_path,
                    "thumbnail_url": f"/api/storage/{thumb_path}",
                }
        except Exception as e:
            import traceback
            error_msg = f"Upload failed for {filename}: {str(e)}"
            print(f"Error in upload_single_file_async: {error_msg}")
            print(traceback.format_exc())
            return {"error": error_msg}
        finally:
            # Clean up temporary files
            if tmp_path and os.path.exists(tmp_path):
                try:
                    os.unlink(tmp_path)
                except:
                    pass
            if thumb_file_path and os.path.exists(thumb_file_path):
                try:
                    os.unlink(thumb_file_path)
                except:
                    pass
    
    # Upload files in parallel (max 5 concurrent uploads)
    saved = []
    errors = []
    
    # For single file, process directly
    if len(file_data_list) == 1:
        filename, file_data = file_data_list[0]
        try:
            result = await upload_single_file_async(filename, file_data)
            if "error" in result:
                raise HTTPException(status_code=500, detail=result["error"])
            saved.append(result)
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Exception uploading {filename}: {str(e)}")
    else:
        # Multiple files: use asyncio.gather for parallel processing
        tasks = [
            upload_single_file_async(filename, file_data)
            for filename, file_data in file_data_list
        ]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        for result in results:
            if isinstance(result, Exception):
                errors.append(f"Exception: {str(result)}")
            elif "error" in result:
                errors.append(result["error"])
            else:
                saved.append(result)
    
    # Return results
    response = {"saved": saved}
    if errors:
        response["errors"] = errors
    
    return response


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "app_fastapi:app",
        host="0.0.0.0",
        port=int(os.environ.get("PORT", "5000")),
        reload=True
    )

